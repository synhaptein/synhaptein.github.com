---
layout: base
title: Kaliya Getting Started
---
{% assign transaction = 'Kaliya' %}
<h2>Getting Started with Kaliya</h2>
<h3>Introduction</h3>
<p>
First of all you should know about mapreduce, if not, I suggest you to read at least this blog entry
<a class="readmore" href="http://www.dashdashverbose.com/2009/01/mapreduce-with-javascript.html">MapReduce with JavaScript</a> from Sean at --verbose 
and <a class="readmore" href="http://labs.google.com/papers/mapreduce.html">MapReduce: Simplified Data Processing on Large Clusters</a> 
from Google Research Publications. You will see that the reverse indexer example is based on Sean word count example.
</p>
<h3>Installation</h3>
<p>
Now it's time to retreive kaliya from github:
</p>
<div class="codeblock">
{% highlight bash %}
git clone git://github.com/synhaptein/kaliya.git
cd kaliya
git checkout -b kaliya-0.1 kaliya-0.1
mvn install
cd kaliya-webapp
mvn jetty:run
{% endhighlight %}
</div>
<p>
Now you should be able to access the management console at this address <span class="codeblock">http://localhost:8080/console</span>.
</p>
<p>
To test the beast, you could add a reverseIndexer job or a md5cracker job (I suggest a word of 3 or 4 characters if you do not want to 
wait to much!) and then connect some browsers to <span class="codeblock">http://localhost:8080/</span>. If nothing
goes wrong, you should see your job being done by your army of browser trying to break your md5 hashes!
</p>
<h3>The reverse indexer example</h3>
<p>
There is two parts in a job:
</p>
<ul>
<li>The java part that feeds the mapreduce engine with an iterator and contains the results.</li>
<li>The javascript part is the mapreduce algorithm implementation for the problem.
</ul>
<p>
Let's see the java part:
</p>
<div class="codeblock">
{% highlight java %}
public class ReverseIndexer extends Job<String, String, List<String>> {
    private List<Pair<String, String>> m_problem;

    public ReverseIndexer(List<Pair<String, String>> p_problem) {
        m_problem = p_problem;
    }

    // Will print this in the job visualisation section of the management console
    public String resultsToString() {
        String result = "";
        if(getStatus() == JobStatus.FINISHED) {
            for(Pair<String, List<String>> pair : m_results) {
                result += pair.key + ": ";
                for(Iterator<String> it = pair.value.iterator(); it.hasNext();) {
                    result += " " + it.next();
                    if(it.hasNext()) {
                        result += ",";
                    }
                }
                result += "<br/>";
            }
        }
        return result;
    }

    public String toString() {
    	// That will be display in the management console for each job
        return "Reverse index of...";
    }

    public String getJobName() {
    	// Very important, it is the name of the javascript object 
    	// that contains the map and reduce function
        return "reverseIndexer"; 
    }

    public void initMapReducer(MapReducer<String, String, List<String>> p_mapReducer) {
        //p_mapReducer.setStopOnFirstMap();
        // This option is not useful for this type of job. It is useful for bruteforcing.
    }

    public Iterator<Pair<String, String>> getIterator() {
        return m_problem.iterator();
    }
}
{% endhighlight %}
</div>
<p>
The most important part is the getIterator() function, the mapreduce engine will iterate on it and
send each entry to an idle worker. The second important thing is the class Job that is extended.
There is three types in a job:
</p> 
<ul>
<li>List&lt;Pair&lt;String, T1&gt;&gt; where T1 is the input type of the map function.</li> 
<li>Map&lt;String, List&lt;T2&gt;&gt; where T2 is the ouput type of the map function.</li>
<li>List&lt;Pair&lt;String, T3&gt;&gt; where T3 is the output type of the reduce function.</li>
</ul>

<p>
So a new job have to extends Job&lt;T1, T2, T3&gt; or JobMapOnly&lt;T1, T2&gt; if the job does not
have to do a reduce.
</p>

<p>
Then have a look at the javascript part:
</p>
<div class="codeblock">
{% highlight javascript %}
function reverseIndexer() {}

reverseIndexer.map = function(key, value) {
    var ret = [];
    var words = normalizeText(value).split(' ');
    for (var i=0; i<words.length; i++) {
        ret.push({key:words[i], value:key});
    }
    return ret;
};

reverseIndexer.reduce = function(intermediateKey, values) {
    var files = new Array();
    var filesSet = new Object();
    for (var i = 0; i < values.length; i++) {
        filesSet[values[i]] = true;
    }
    for (var file in filesSet) {
        files.push(file);
    }
    return {key:intermediateKey, value:files};
};

function normalizeText(s) {
    s = s.toLowerCase();
    s = s.replace(/[^a-z]+/g, ' ');
    return s;
}
{% endhighlight %}
</div>
<h3>Conclusion</h3>
<p>
It is now easy to distribute jobs on a bunch of computers without any additional software. There is a lot of enhancements that could be
done to Kaliya like those: 
</p>
<ul>
<li>stop/pause/resume a single job</li> 
<li>recover a task when a worker is disconnected or an error occured</li>
<li>statistics on a job like time, task speed...</li>
</ul>
<p>
Also there is some gaps with it that make it a toy:
</p>
<ul>
<li>a central point of failure, that keeps all the map results and do the groupby function.</li> 
<li>mapreduce algorithms need to be optimized on reducing data transfer between the server and the nodes. That means more CPU power to do the same job.</li>
<li>javascript is much slower than native compiled code! I don't even know if it's possible to reach a 
C implementation performance of md5cracker with Kaliya by adding a lot of nodes.</li>
</ul>
